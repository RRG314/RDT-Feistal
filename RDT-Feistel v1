"""
RDT-Feistel v1 — Core Deterministic Recursive-Entropy Permutation
Author: Steven Reid (2025)

Pure recursive-geometric Feistel transform.
Produces near-maximal Shannon entropy from structured data
while remaining fully deterministic and reversible.
"""

import math, time
from collections import Counter

φ = 1.6180339887498948  # golden ratio

# --- utilities --------------------------------------------------------------
def rotl8(x, r): r &= 7; return ((x << r) & 0xFF) | (x >> (8 - r))

def rdt_depth(n, α=1.5):
    if n < 2: return 0
    d, x = 0, n
    while x > 1:
        s = int(math.log(x)**α); s = max(2, s)
        x //= s; d += 1
    return d

# --- RDT-Feistel v1 core ----------------------------------------------------
def mixer_rdt_feistel_v1(data: bytes, rounds=4, α=1.5):
    n = len(data)
    x = bytearray(data)

    # build RDT permutation
    idx = list(range(n))
    idx.sort(key=lambda i: (rdt_depth(i+2, α),
                            (i ^ (i*2654435761 & 0xFFFFFFFF)) & 0xFFFFFFFF,
                            i))
    Pinv = [0]*n
    for j,i0 in enumerate(idx): Pinv[i0]=j

    half = n//2
    L, R = x[:half], x[half:]

    for r in range(1, rounds+1):
        Rp = bytearray(len(R))
        for k in range(len(R)):
            j = (Pinv[half+k]-half) % max(1, len(R))
            Rp[k] = R[j]
        F = bytearray(len(L))
        for i in range(len(L)):
            rs = (int(φ*(i+13*r)) % 7) + 1
            a,b = Rp[i%len(Rp)], Rp[(i*3+r)%len(Rp)]
            c = rotl8(a^b, rs)
            d = ((i*37+19*r) & 0xFF)
            F[i] = (c ^ d) & 0xFF
        L, R = R, bytearray((L[i]^F[i%len(F)]) for i in range(len(R)))
        for i in range(len(R)):
            R[i] = rotl8(R[i]^((i*11+7*r)&0xFF),(i+r)&7)

    out = bytearray(n); out[:len(L)] = L; out[len(L):] = R
    return bytes(out)

# --- quick benchmark --------------------------------------------------------
def H_shannon(b): N=len(b); c=Counter(b); return -sum((v/N)*math.log2(v/N) for v in c.values())
def chi_square(b): N=len(b); c=Counter(b); exp=N/256; return sum((v-exp)**2/exp for v in c.values())

if __name__ == "__main__":
    size = 32768
    data = bytes([i % 256 for i in range(size)])
    t0 = time.time(); out = mixer_rdt_feistel_v1(data); t1 = time.time()
    print("=== RDT-Feistel v1 ===")
    print(f"Entropy (bits/byte): {H_shannon(out):.4f}")
    print(f"Chi-square: {chi_square(out):.1f}")
    print(f"Time: {(t1-t0)*1000:.1f} ms for {size} bytes")
